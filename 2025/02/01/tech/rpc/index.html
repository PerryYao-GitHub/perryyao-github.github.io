<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="In this blog, I will give an elaborate instruction to the process of how to construct a whole RPC framework with Java.  It is also a record of project demo-pyrpc and demo-rpc, the former one is an u">
<meta property="og:type" content="article">
<meta property="og:title" content="PyRPC Framework">
<meta property="og:url" content="http://example.com/2025/02/01/tech/rpc/index.html">
<meta property="og:site_name" content="Perry&#39;s Blog">
<meta property="og:description" content="In this blog, I will give an elaborate instruction to the process of how to construct a whole RPC framework with Java.  It is also a record of project demo-pyrpc and demo-rpc, the former one is an u">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2025-01-31T16:00:00.000Z">
<meta property="article:modified_time" content="2025-05-16T10:27:15.738Z">
<meta property="article:author" content="Perry Yao">
<meta property="article:tag" content="rpc">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2025/02/01/tech/rpc/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>PyRPC Framework | Perry's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Perry's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">tech & muse & sleep</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>Schedule</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/02/01/tech/rpc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars.githubusercontent.com/u/126999663?v=4">
      <meta itemprop="name" content="Perry Yao">
      <meta itemprop="description" content="...">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Perry's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          PyRPC Framework
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-02-01 00:00:00" itemprop="dateCreated datePublished" datetime="2025-02-01T00:00:00+08:00">2025-02-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-05-16 18:27:15" itemprop="dateModified" datetime="2025-05-16T18:27:15+08:00">2025-05-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/tech/" itemprop="url" rel="index"><span itemprop="name">tech</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <hr>
<blockquote>
<p>In this blog, I will give an elaborate instruction to the process of how to construct a whole RPC framework with Java. </p>
<p>It is also a record of project <a target="_blank" rel="noopener" href="https://github.com/PerryYao-GitHub/demo-pyrpc">demo-pyrpc</a> and <a target="_blank" rel="noopener" href="https://github.com/PerryYao-GitHub/demo-rpc">demo-rpc</a>, the former one is an update on the last one.</p>
</blockquote>
<h1 id="pyRPC-Framework"><a href="#pyRPC-Framework" class="headerlink" title="pyRPC Framework"></a>pyRPC Framework</h1><h2 id="What-is-RPC"><a href="#What-is-RPC" class="headerlink" title="What is RPC?"></a>What is RPC?</h2><p>RPC (Remote Procedure Call) 远程过程调用, 是一种计算机通信协议, 允许程序在不同计算机之间通信和交互, 就像本地调用一样.</p>
<h2 id="Consumer-Provider-Model"><a href="#Consumer-Provider-Model" class="headerlink" title="Consumer &#x2F; Provider Model"></a>Consumer &#x2F; Provider Model</h2><p>RPC 框架本身不是一个独立运行的服务, 而是一个被 Consumer (调用方) 和 Provider (服务提供方) 引入的库 (SDK). RPC 框架的主要作用是为开发者提供远程服务调用的能力; 同时抽象网络通信, 序列化&#x2F;反序列化等底层细节. </p>
<p>RPC 完成通信的主要过程为:</p>
<h3 id="共享模块-common-example"><a href="#共享模块-common-example" class="headerlink" title="共享模块 (common-example)"></a>共享模块 (common-example)</h3><ul>
<li>共享模块 (SDK), 不在服务器上运行, 给各个开发组件提供规范化的数据类型和接口</li>
<li>有两个实体类: <code>User</code> and <code>Music</code>, 含有基本数据类型和集合数据类型</li>
<li>规定两个接口: <code>UserService</code> and <code>MusicService</code>, 包含 <code>getUserById</code> and <code>getMusicById</code> 方法</li>
</ul>
<h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><ul>
<li>需引入 common-example &amp; pyrpc</li>
<li>模拟服务消费者, 运行在服务器上</li>
</ul>
<h4 id="zero-初始化-Consumer-端配置"><a href="#zero-初始化-Consumer-端配置" class="headerlink" title=":zero:初始化 Consumer 端配置"></a>:zero:初始化 Consumer 端配置</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RpcApplication.init();</span><br></pre></td></tr></table></figure>

<p>主要是读取 Consumer 端的配置信息. </p>
<h4 id="one-Consumer-使用动态代理工厂-ServiceProxyFactory-获取代理对象"><a href="#one-Consumer-使用动态代理工厂-ServiceProxyFactory-获取代理对象" class="headerlink" title=":one:Consumer 使用动态代理工厂 ServiceProxyFactory 获取代理对象"></a>:one:Consumer 使用动态代理工厂 <code>ServiceProxyFactory</code> 获取代理对象</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UserService userService = ServiceProxyFactory.getProxy(UserService.class);</span><br></pre></td></tr></table></figure>

<p>然后就可以对 <code>userService</code> 像在本地一样调用其中的方法.</p>
<p>其中 <code>ServiceProxyFactory</code> 内部存储了 <code>ServiceProxy</code> 的实例 (使用 static 的单例存储, 避免过多的对象创建). </p>
<h4 id="two-ServiceProxy-帮助-Consumer-完成对请求的封装-发送-并接受响应"><a href="#two-ServiceProxy-帮助-Consumer-完成对请求的封装-发送-并接受响应" class="headerlink" title=":two:ServiceProxy 帮助 Consumer 完成对请求的封装, 发送, 并接受响应"></a>:two:<code>ServiceProxy</code> 帮助 Consumer 完成对请求的封装, 发送, 并接受响应</h4><p>在 <code>ServiceProxy</code> 中, 执行了以下关键内容:</p>
<ol>
<li><p>将调用者调用的方法, 传入的参数封装成标准化的 <code>RpcRequest rpcRequest</code></p>
</li>
<li><p>使用序列化器序列化 <code>rpcRequest</code></p>
</li>
<li><p>向 Provider 的的 RPC 服务端点发送请求</p>
</li>
<li><p>待获取 RPC 的响应数据后, 反序列化它, 将其转化成 <code>RpcResponse rpcResponse</code>, 并抽取其中的数据字段 (这才是 Consumer 真正想拿到的东西)</p>
</li>
</ol>
<h3 id="Provider-provider-example"><a href="#Provider-provider-example" class="headerlink" title="Provider (provider-example)"></a>Provider (provider-example)</h3><ul>
<li>需引入 common-example &amp; pyrpc</li>
<li>模拟服务提供者, 运行在服务器上</li>
<li>它实现了共享模块中的 <code>UserService</code> and <code>MusicService</code></li>
</ul>
<h4 id="zero-Provider-的初始化流程"><a href="#zero-Provider-的初始化流程" class="headerlink" title=":zero:Provider 的初始化流程"></a>:zero:Provider 的初始化流程</h4><ol>
<li><p>读入配置信息</p>
</li>
<li><p>把自己想提供的服务注册到 <code>RpcLocalRegistry</code> (本地注册中心)</p>
</li>
<li><p>开启一个Web 服务器, 监听 RPC 请求</p>
</li>
</ol>
<h4 id="one-RpcServer帮助-Provider-完成对请求的接收-解析-并发送响应"><a href="#one-RpcServer帮助-Provider-完成对请求的接收-解析-并发送响应" class="headerlink" title=":one:RpcServer帮助 Provider 完成对请求的接收, 解析, 并发送响应"></a>:one:<code>RpcServer</code>帮助 Provider 完成对请求的接收, 解析, 并发送响应</h4><p>RPC 框架帮助 Provider 接受并处理请求的核心逻辑在 <code>server</code> 包中, 即开启一个 Web 服务器来处理发送过来的 RPC 请求, 并把结果发送回去; 而其中的处理请求的逻辑, 则单独封装在 <code>ServerHandler</code> 中. </p>
<p><code>RpcServer</code> 中的逻辑是一个异步处理模型. 当有请求过来时, 遵循以下步骤: 请求解析 -&gt; 服务方法调用 -&gt; 结果封装 -&gt; 响应返回. </p>
<h3 id="RPC-pyrpc"><a href="#RPC-pyrpc" class="headerlink" title="RPC (pyrpc)"></a>RPC (pyrpc)</h3><p>连接 Consumer 和 Provider 通信的枢纽, 接下来重点介绍.</p>
<h2 id="Main-Components-in-pyRPC"><a href="#Main-Components-in-pyRPC" class="headerlink" title="Main Components in pyRPC"></a>Main Components in pyRPC</h2><h3 id="数据组件和配置组件-com-ypy-pyrpc-model-com-ypy-pyrpc-config"><a href="#数据组件和配置组件-com-ypy-pyrpc-model-com-ypy-pyrpc-config" class="headerlink" title="数据组件和配置组件: com.ypy.pyrpc.model &amp; com.ypy.pyrpc.config"></a>数据组件和配置组件: <code>com.ypy.pyrpc.model</code> &amp; <code>com.ypy.pyrpc.config</code></h3><p>其中定义了 <code>RpcRequest</code>, <code>RpcResponse</code>, <code>ServiceMetaInfo</code>, <code>ServiceRegisterInfo</code> 等基本数据类型.</p>
<p>以及RPC框架的配置数据类型 (<code>RpcConfig</code> and <code>RpcConfig.RegistryConfig</code>) 和一个用于读取配置文件的工具类 (<code>RpcConfigReader</code>).</p>
<p>本框架的配置信息可以写入<code>resources/application.properties</code>, 完整的配置信息如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pyrpc.serverHost=127.0.0.1</span><br><span class="line">pyrpc.serverPort=8081</span><br><span class="line">pyrpc.serverType=http || tcp</span><br><span class="line">pyrpc.mock=false || true</span><br><span class="line">pyrpc.registry.registry=no || etcd</span><br><span class="line">pyrpc.registry.addr=http://127.0.0.1:2375</span><br><span class="line">pyrpc.registry.username=xxx</span><br><span class="line">pyrpc.registry.password=yyy</span><br><span class="line">pyrpc.registry.timeout=10000</span><br><span class="line">pyrpc.serializer=jdk || json || kryo</span><br><span class="line">pyrpc.loadbalancer=round-robin || random || consistent-hash</span><br><span class="line">pyrpc.retry=no || fixed-interval</span><br><span class="line">pyrpc.tolerance=fail-fast || fail-safe</span><br></pre></td></tr></table></figure>

<p><em>*其中 || 分割了可供选择的默认实现类的 key</em></p>
<p>在 <code>resources/META-INF/prrpc/</code> 中, 有 <code>custom/</code> 和 <code>system/</code> 两个目录, 其中 <code>system/</code> 中的文件如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">com.ypy.pyrpc.spi.loadbalancer.Loadbalancer</span><br><span class="line">com.ypy.pyrpc.spi.registry.Registry</span><br><span class="line">com.ypy.pyrpc.spi.retry.Retry</span><br><span class="line">com.ypy.pyrpc.spi.serializer.Serializer</span><br><span class="line">com.ypy.pyrpc.spi.tolerance.Tolerance</span><br></pre></td></tr></table></figure>

<p>分别对应了提供 SPI 自定义功能实现类的接口名, 在相对应的文件内, 可以写入功能实现类以及其对应的 key. 框架中的默认实现类以及 key 如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">round-robin=com.ypy.pyrpc.spi.loadbalancer.impl.RoundRobinLoadbalancer</span><br><span class="line">random=com.ypy.pyrpc.spi.loadbalancer.impl.RandomLoadbalancer</span><br><span class="line">consistent-hash=com.ypy.pyrpc.spi.loadbalancer.impl.ConsistentHashLoadbalancer</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">no=com.ypy.pyrpc.spi.registry.impl.NoRegistry</span><br><span class="line">etcd=com.ypy.pyrpc.spi.registry.impl.EtcdRegistry</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">no=com.ypy.pyrpc.spi.retry.impl.NoRetry</span><br><span class="line">fixed-interval=com.ypy.pyrpc.spi.retry.impl.FixedIntervalRetry</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jdk=com.ypy.pyrpc.spi.serializer.impl.JdkSerializer</span><br><span class="line">json=com.ypy.pyrpc.spi.serializer.impl.JsonSerializer</span><br><span class="line">kryo=com.ypy.pyrpc.spi.serializer.impl.KryoSerializer</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fail-fast=com.ypy.pyrpc.spi.tolerance.impl.FailFastTolerance</span><br><span class="line">fail-safe=com.ypy.pyrpc.spi.tolerance.impl.FailSafeTolerance</span><br></pre></td></tr></table></figure>

<h3 id="启动组件-com-ypy-pyrpc-bootstrap"><a href="#启动组件-com-ypy-pyrpc-bootstrap" class="headerlink" title="启动组件 com.ypy.pyrpc.bootstrap"></a>启动组件 <code>com.ypy.pyrpc.bootstrap</code></h3><p><strong>:star:Consumer 启动类 <code>ConsumerBootstrap</code></strong></p>
<p>帮助 Consumer 初始化, 其基本逻辑是调用 <code>com.ypy.pyrpc.app.RpcApplication</code>, 来完成对配置信息的读取. 本质上只是对 <code>com.ypy.pyrpc.app.RpcApplication</code> 进行了一层封装, 规范了代码结构.</p>
<p><strong>:star:Provider 启动类 <code>ProviderBoostrap</code></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProviderBootstrap</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(List&lt;ServiceRegisterInfo&gt; serviceRegisterInfoList)</span> &#123;</span><br><span class="line">        RpcApplication.init();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">RpcConfig</span> <span class="variable">rpcConfig</span> <span class="operator">=</span> RpcApplication.getRpcConfig();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (ServiceRegisterInfo&lt;?&gt; serviceRegisterInfo : serviceRegisterInfoList) &#123;</span><br><span class="line">            RpcLocalRegistry.register(serviceRegisterInfo.getServiceInterfaceName(), serviceRegisterInfo.getServiceImplClass());</span><br><span class="line"></span><br><span class="line">            RpcConfig.<span class="type">RegistryConfig</span> <span class="variable">registryConfig</span> <span class="operator">=</span> rpcConfig.getRegistryConfig();</span><br><span class="line">            <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> RegistryFactory.getInstance(registryConfig.getRegistry());</span><br><span class="line">            <span class="type">ServiceMetaInfo</span> <span class="variable">serviceMetaInfo</span> <span class="operator">=</span> ServiceMetaInfo.builder()</span><br><span class="line">                    .serviceName(serviceRegisterInfo.getServiceInterfaceName())</span><br><span class="line">                    .serviceVersion(RpcConstant.DEFAULT_SERVICE_VERSION) <span class="comment">// todo</span></span><br><span class="line">                    .serviceHost(rpcConfig.getServerHost())</span><br><span class="line">                    .servicePost(rpcConfig.getServerPort())</span><br><span class="line">                    .build();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                registry.register(serviceMetaInfo);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(serviceRegisterInfo.getServiceInterfaceName() + <span class="string">&quot; register failed&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">RpcServer</span> <span class="variable">rpcServer</span> <span class="operator">=</span> RpcServerFactory.getInstance(RpcApplication.getRpcConfig().getServerType());</span><br><span class="line">        rpcServer.start(rpcConfig.getServerPort());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用 <code>RpcApplication.init()</code> 初始化 RPC 框架, 读取配置信息</li>
<li>把 <code>serviceRegisterInfoList</code> 中的服务注册到本地注册中心 (<code>RpcLocalRegistry</code>)</li>
<li>根据全局配置, 通过注册中心代理工厂 (<code>RegistryFactory</code>) 获取相对应的注册中心对象, 把服务写入注册中心</li>
<li>开启PRC Web 服务器, 在相应的端口专门处理RPC请求</li>
</ul>
<p><em>注意: 把服务注册到本地和把服务注册到注册中心是不同的</em></p>
<ul>
<li>本地注册: 把服务接口信息和服务实现类以单例模式存入 <code>RpcLocalRegistry</code>, 方便处理RPC请求时调用</li>
<li>注册中心: 把服务的信息 (<code>com.ypy.pyrpc.model.ServiceMetaInfo</code>, 主要包含服务名和服务提供者的地址) 存入一个键值型数据库 (例如 ETCD 或 Redis), 这个数据库服务是独立与所有 Provider 的, 因此但不同的 Provider 提供不同的服务时, 注册中心充当了一个 “信息集散地”: RPC 框架帮助 Consumer 在注册中心获取服务的地址, 并挑选合适的服务节点; 当允许多个 Provider 提供相同服务时, 可以使用负载均衡减少服务器压力</li>
</ul>
<h3 id="全局组件-com-ypy-pyrpc-app"><a href="#全局组件-com-ypy-pyrpc-app" class="headerlink" title="全局组件 com.ypy.pyrpc.app"></a>全局组件 <code>com.ypy.pyrpc.app</code></h3><p><strong>:star:RPC初始化工具类<code>RpcApplication</code></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcApplication</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> RpcConfig rpcConfig;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * init RpcConfig</span></span><br><span class="line"><span class="comment">     * and Registry</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newRpcConfig</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(RpcConfig newRpcConfig)</span> &#123;</span><br><span class="line">        <span class="comment">// config</span></span><br><span class="line">        rpcConfig = newRpcConfig;</span><br><span class="line">        log.info(<span class="string">&quot;RpcApplication initialized with config: &#123;&#125;&quot;</span>, rpcConfig);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// registry</span></span><br><span class="line">        RpcConfig.<span class="type">RegistryConfig</span> <span class="variable">registryConfig</span> <span class="operator">=</span> rpcConfig.getRegistryConfig();</span><br><span class="line">        <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> RegistryFactory.getInstance(registryConfig.getRegistry());</span><br><span class="line">        registry.init(registryConfig);</span><br><span class="line">        log.info(<span class="string">&quot;Registry initialized with config: &#123;&#125;&quot;</span>, registryConfig);</span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> <span class="title class_">Thread</span>(registry::destroy));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        RpcConfig newRpcConfig;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            newRpcConfig = RpcConfigReader.loadConfig(RpcConstant.DEFAULT_CONFIG_PREFIX);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;Failed to load configuration file. Using default config.&quot;</span>, e);</span><br><span class="line">            newRpcConfig = <span class="keyword">new</span> <span class="title class_">RpcConfig</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        init(newRpcConfig);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> RpcConfig <span class="title function_">getRpcConfig</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (rpcConfig == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (RpcApplication.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rpcConfig == <span class="literal">null</span>) init();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rpcConfig;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>工具类, 是RPC框架初始化的公共逻辑, 其中都是静态方法和静态成员变量. 维护了一个静态的 <code>RpcConfig</code> 实例, 它包含了 RPC 的全部配置信息. 代码中使用工具类 <code>com.ypy.pyrpc.config.RpcConfigReader</code> 中的静态方法<code>loadConfig</code> 读取程序员在项目 <code>/resourses/application.properties</code> 中写的配置信息. </p>
<p><strong>:star:本地注册中心 <code>RpcLocalRegistry</code></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcLocalRegistry</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Class&lt;?&gt;&gt; registeredServiceImpl = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;String, Class&lt;?&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(String serviceName, Class&lt;?&gt; serviceImpl)</span> &#123;</span><br><span class="line">        registeredServiceImpl.put(serviceName, serviceImpl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; getServiceImpl(String serviceName) &#123;</span><br><span class="line">        <span class="keyword">return</span> registeredServiceImpl.get(serviceName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">removeService</span><span class="params">(String serviceName)</span> &#123;</span><br><span class="line">        registeredServiceImpl.remove(serviceName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>工具类, 维护了一个静态的 <code>ConcurrentHashMap&lt;String, Class&lt;?&gt;&gt;</code> 用于存储 Provider 提供的服务名和对应实现类的Class类</p>
<h3 id="代理组件-com-ypy-pyrpc-proxy"><a href="#代理组件-com-ypy-pyrpc-proxy" class="headerlink" title="代理组件 com.ypy.pyrpc.proxy"></a>代理组件 <code>com.ypy.pyrpc.proxy</code></h3><p>这一部分是 Consumer 发送 RPC 请求的核心</p>
<p><strong>:star:消费者服务代理 <code>ServiceProxy</code></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceProxy</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">serviceName</span> <span class="operator">=</span> method.getDeclaringClass().getName();</span><br><span class="line">        <span class="type">RpcRequest</span> <span class="variable">rpcRequest</span> <span class="operator">=</span> RpcRequest.builder()</span><br><span class="line">                .serviceName(serviceName)</span><br><span class="line">                .methodName(method.getName())</span><br><span class="line">                .parameterTypes(method.getParameterTypes())</span><br><span class="line">                .args(args)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> RegistryFactory.getInstance(RpcApplication.getRpcConfig().getRegistryConfig().getRegistry());</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">serviceNameVer</span> <span class="operator">=</span> ServiceMetaInfo.serviceNameVer(serviceName, RpcConstant.DEFAULT_SERVICE_VERSION);</span><br><span class="line">        List&lt;ServiceMetaInfo&gt; serviceMetaInfoList = registry.serviceDiscovery(serviceNameVer);</span><br><span class="line"></span><br><span class="line">        <span class="type">Loadbalancer</span> <span class="variable">loadbalancer</span> <span class="operator">=</span> LoadbalancerFactory.getInstance(RpcApplication.getRpcConfig().getLoadbalancer());</span><br><span class="line">        Map&lt;String, Object&gt; context = Map.of(<span class="string">&quot;serviceNameVer&quot;</span>, serviceNameVer);</span><br><span class="line">        <span class="type">ServiceMetaInfo</span> <span class="variable">serviceMetaInfo</span> <span class="operator">=</span> loadbalancer.select(serviceMetaInfoList, context);</span><br><span class="line"></span><br><span class="line">        <span class="type">RpcClient</span> <span class="variable">rpcClient</span> <span class="operator">=</span> RpcClientFactory.getInstance(RpcApplication.getRpcConfig().getServerType());</span><br><span class="line">        RpcResponse rpcResponse;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Retry</span> <span class="variable">retry</span> <span class="operator">=</span> RetryFactory.getInstance(RpcApplication.getRpcConfig().getRetry());</span><br><span class="line">            rpcResponse = retry.retry(() -&gt; rpcClient.request(rpcRequest, serviceMetaInfo));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="type">Tolerance</span> <span class="variable">tolerance</span> <span class="operator">=</span> ToleranceFactory.getInstance(RpcApplication.getRpcConfig().getTolerance());</span><br><span class="line">            rpcResponse = tolerance.tolerate(e, context);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rpcResponse.getData();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个类可以说是为 Consumer 发送RPC请求的核心, 代码的主要逻辑是:</p>
<ul>
<li>把由参数获取的服务接口名, 服务方法名, 参数类型及参数封装进入<code>rpcRequest</code></li>
<li>根据全局静态配置信息获取注册中心 (<code>registry</code>) 并通过注册中心根据服务名和版本信息发现服务</li>
<li>根据全局静态配置信息获取负载均衡器 (<code>loadbalancer</code>) 并通过负载均衡器选择适合的服务 Provider 节点</li>
<li>使用 <code>RpcClient.request()</code> 静态方法发送 RPC 请求 (这里的逻辑在 RPC Server 部分解释)</li>
<li>根据全局静态配置信息获取重试和容错器, 在出现问题进行相应的处理步骤</li>
<li>获得 <code>rpcResonse</code> 返回其 <code>data</code> 部分</li>
</ul>
<p><strong>:star:Mock服务代理 <code>MockServiceProxy</code></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MockServiceProxy</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        Class&lt;?&gt; methodReturnType = method.getReturnType();</span><br><span class="line">        log.info(<span class="string">&quot;mock invoke &#123;&#125;&quot;</span>, method.getName());</span><br><span class="line">        <span class="keyword">return</span> getDefaultObject(methodReturnType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object <span class="title function_">getDefaultObject</span><span class="params">(Class&lt;?&gt; type)</span> &#123;</span><br><span class="line">        <span class="comment">// 8 primitive type</span></span><br><span class="line">        <span class="keyword">if</span> (type == <span class="type">boolean</span>.class || type == Boolean.class) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="type">byte</span>.class || type == Byte.class) <span class="keyword">return</span> (<span class="type">byte</span>) <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="type">short</span>.class || type == Short.class) <span class="keyword">return</span> (<span class="type">short</span>) <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="type">char</span>.class || type == Character.class) <span class="keyword">return</span> (<span class="type">char</span>) <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="type">int</span>.class || type == Integer.class) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="type">long</span>.class || type == Long.class) <span class="keyword">return</span> <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="type">float</span>.class || type == Float.class) <span class="keyword">return</span> <span class="number">0.0f</span>;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="type">double</span>.class || type == Double.class) <span class="keyword">return</span> <span class="number">0.0d</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// handle common type</span></span><br><span class="line">        <span class="keyword">if</span> (type == String.class) <span class="keyword">return</span> <span class="string">&quot;&lt;mock&gt;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (type == List.class) <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">        <span class="keyword">if</span> (type == Map.class) <span class="keyword">return</span> Collections.emptyMap();</span><br><span class="line">        <span class="keyword">if</span> (type == Set.class) <span class="keyword">return</span> Collections.emptySet();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// handle self-defined class</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> type.getDeclaredConstructor().newInstance();</span><br><span class="line">            Field[] fields = type.getDeclaredFields();</span><br><span class="line">            <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">                field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                Class&lt;?&gt; fieldType = field.getType();</span><br><span class="line">                field.set(instance, getDefaultObject(fieldType)); <span class="comment">// recursion</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;Failed to create mock object for type: &#123;&#125;&quot;</span>, type.getName(), e);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为开发者提供生成假数据的服务代理, 当 Consumer 开发者在不存在 Provider 的情况下, 也能调用假服务, 获取假数据</p>
<p><strong>:star:代理服务工厂 <code>ServiceProxyFactory</code></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceProxyFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">getProxy</span><span class="params">(Class&lt;T&gt; serviceInterface)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (RpcApplication.getRpcConfig().isMock()) <span class="keyword">return</span> getMockProxy(serviceInterface);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (T) Proxy.newProxyInstance(</span><br><span class="line">                serviceInterface.getClassLoader(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;serviceInterface&#125;,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ServiceProxy</span>()</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">getMockProxy</span><span class="params">(Class&lt;T&gt; serviceInterface)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (T) Proxy.newProxyInstance(</span><br><span class="line">                serviceInterface.getClassLoader(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;serviceInterface&#125;,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">MockServiceProxy</span>()</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Proxy.newProxyInstance</code> 是 JDK 提供的动态代理工具方法, 它需要三个参数: <ul>
<li><code>ClassLoader</code>: 用于加载代理类的类加载器</li>
<li><code>Class&lt;?&gt;[]</code>: 代理类需要实现的接口列表</li>
<li><code>InvocationHandler</code>: 代理类的调用处理器, 负责拦截方法调用并执行自定义逻辑</li>
</ul>
</li>
<li>在这里, <code>ServiceProxy</code> 和 <code>MockServiceProxy</code> 都实现了 <code>InvocationHandler</code> 接口, 分别用于处理真实的 RPC 调用和 Mock 调用</li>
</ul>
<h3 id="服务器组件-com-ypy-pyrpc-server"><a href="#服务器组件-com-ypy-pyrpc-server" class="headerlink" title="服务器组件 com.ypy.pyrpc.server"></a>服务器组件 <code>com.ypy.pyrpc.server</code></h3><p>这一部分是 Provider 处理 RPC 请求的重点, 也是 RPC 通信的重点. 该包中有两个重要的接口: <code>RpcClient</code> 和 <code>RpcServer</code>. </p>
<p><code>RpcClient</code> 只有一个方法 <code>RpcResponse request(RpcRequest rpcRequest, ServiceMetaInfo serviceMetaInfo) throws Exception;</code>. 它是发送 RPC 请求的核心. 注意, 这里的发送请求不是 <code>ServiceProxy</code> 的普通业务逻辑. 这里的主要是要实现序列化&#x2F;反序列化, 以及使用TCP协议发送请求. </p>
<p><code>RpcServer</code> 也只有一个方法 <code>void start(int port);</code>. 它.帮助 Provider 在相应端口构造 Web 服务, 并处理 RPC 请求.</p>
<p>同时, 它们都有各自对应的工厂类 (<code>RpcClientFactory</code> &amp; <code>RpcServerFactory</code>), 以 <code>RpcClientFactory</code> 为例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcClientFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, RpcClient&gt; clientMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        clientMap.put(RpcServerTypeKeys.TCP, <span class="keyword">new</span> <span class="title class_">TcpClient</span>());</span><br><span class="line">        clientMap.put(RpcServerTypeKeys.HTTP, <span class="keyword">new</span> <span class="title class_">HttpClient</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> RpcClient <span class="title function_">getInstance</span><span class="params">(String implClassKey)</span> &#123; <span class="keyword">return</span> clientMap.get(implClassKey); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于我们不能每发一次 RPC 请求就 new 一个 <code>TcpClient</code> 或 <code>HttpClient</code> 实现类, 于是我们选择使用工厂模式, 维护一个静态的Map, 存储了对应的 <code>RpcClient</code> 的实现类, 会根据对应的 key 返回相应的实现类. <code>RpcServerFactory</code> 同理. 这样即避免了重复 new 对象, 同时也允许开发者配置自己喜欢的底层通信协议 (TCP or HTTP).</p>
<p>接下来我们主要看看使用 TCP 协议作为底层协议, 是如何实现 <code>RpcClient</code> 和 <code>RpcServer</code> 的:</p>
<h4 id="协议数据结构组件-com-ypy-pyrpc-server-tcp-protocol"><a href="#协议数据结构组件-com-ypy-pyrpc-server-tcp-protocol" class="headerlink" title="协议数据结构组件 com.ypy.pyrpc.server.tcp.protocol"></a>协议数据结构组件 <code>com.ypy.pyrpc.server.tcp.protocol</code></h4><p>这里主要定义了自定义协议的结构 (<code>Protocol</code>):</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Protocol</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="meta">@Builder</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Header</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">byte</span> magic;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">byte</span> version;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">byte</span> serializer;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">byte</span> type;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">byte</span> status;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">long</span> requestId;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> bodyLength;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Header header;</span><br><span class="line">    <span class="keyword">private</span> T body; <span class="comment">// body: RpcRequest or RpcResponse, will be serialized into bytes</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以及其它协议常量以及枚举</p>
<h4 id="TCP-服务器实现组件-com-ypy-pyrpc-server-tcp"><a href="#TCP-服务器实现组件-com-ypy-pyrpc-server-tcp" class="headerlink" title="TCP 服务器实现组件 com.ypy.pyrpc.server.tcp"></a>TCP 服务器实现组件 <code>com.ypy.pyrpc.server.tcp</code></h4><p><strong>:star:TCP 服务器实现 <code>TcpServer</code></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TcpServer</span> <span class="keyword">implements</span> <span class="title class_">RpcServer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(<span class="type">int</span> port)</span> &#123;</span><br><span class="line">        <span class="type">Vertx</span> <span class="variable">vertx</span> <span class="operator">=</span> Vertx.vertx();</span><br><span class="line">        <span class="type">NetServer</span> <span class="variable">server</span> <span class="operator">=</span> vertx.createNetServer();</span><br><span class="line">        server.connectHandler(<span class="keyword">new</span> <span class="title class_">TcpServerHandler</span>());</span><br><span class="line">        server.listen(port, netServerAsyncResult -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (netServerAsyncResult.succeeded()) System.out.println(<span class="string">&quot;TcpServer started on port &quot;</span> + port);</span><br><span class="line">            <span class="keyword">else</span> System.out.println(<span class="string">&quot;TcpServer failed to start on port &quot;</span> + port);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码的首先使用 <code>Vertx</code> 构造一个 Web 服务器: 这里的 <code>vertx</code> 虽然不是<code>static</code> 的, 但是因为整个 <code>TcpServcer</code> 会被以单例的形式存储在工厂类的静态变量中, 并且 <code>start</code> 方法只会在 Provider 初始化中被调用一次, 因此不存在重复实例化对象 (<code>Vertx</code> 实例) 的问题. 也就是说, 整个 Provider 中, 只会存在一个 <code>Vertx</code> 实例. 但是, 这并不影响RPC请求的并发处理, 因为:</p>
<ul>
<li><strong><code>Vert.x</code> 的特性</strong>：<br><code>Vert.x</code> 是一个事件驱动的框架, 它的核心思想是<strong>非阻塞 I&#x2F;O</strong> 和<strong>事件循环</strong>. 当你在 <code>TcpServer</code> 中使用 <code>Vert.x</code> 的 <code>NetServer</code> 时，<code>Vert.x</code> 会自动处理多个并发连接, 并且每个连接的处理是非阻塞的. 这意味着: <ul>
<li>多个 Consumer 发送的请求会被 <code>Vert.x</code> 并发处理，而不是顺次处理. </li>
<li><code>Vert.x</code> 的事件循环机制会确保高并发请求的高效处理.</li>
</ul>
</li>
<li><strong>Provider 中的 <code>RpcServer</code> 实例</strong>：<br>在 Provider 中只启动了一个 <code>RpcServer</code> 实例 (例如 <code>TcpServer</code>), 但由于 <code>Vert.x</code> 的异步和非阻塞特性, 这个实例可以同时处理多个 Consumer 的请求. 每个请求都会由 <code>Vert.x</code> 的事件循环分配到不同的线程 (或事件循环线程) 中处理.</li>
</ul>
<p>最后, 使用 <code>.connectHandler()</code> 方法绑定处理器.</p>
<p><strong>:star:TCP 处理器 <code>TcpServerHandler</code></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TcpServerHandler</span> <span class="keyword">implements</span> <span class="title class_">Handler</span>&lt;NetSocket&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(NetSocket netSocket)</span> &#123;</span><br><span class="line">        <span class="type">TcpBufferHandlerWrapper</span> <span class="variable">bufferHandlerWrapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TcpBufferHandlerWrapper</span>(buffer -&gt; &#123;</span><br><span class="line">            Protocol&lt;RpcRequest&gt; protocol;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                protocol = (Protocol&lt;RpcRequest&gt;) ProtocolUtils.decode(buffer);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Decode Err&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">RpcRequest</span> <span class="variable">rpcRequest</span> <span class="operator">=</span> protocol.getBody();</span><br><span class="line">            <span class="type">RpcResponse</span> <span class="variable">rpcResponse</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RpcResponse</span>();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Class&lt;?&gt; serviceImpl = RpcLocalRegistry.getServiceImpl(rpcRequest.getServiceName());</span><br><span class="line">                <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> serviceImpl.getMethod(rpcRequest.getMethodName(), rpcRequest.getParameterTypes());</span><br><span class="line">                <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(serviceImpl.newInstance(), rpcRequest.getArgs());</span><br><span class="line"></span><br><span class="line">                rpcResponse.setData(result);</span><br><span class="line">                rpcResponse.setDataType(method.getReturnType());</span><br><span class="line">                rpcResponse.setMsg(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                rpcResponse.setMsg(e.getMessage());</span><br><span class="line">                rpcResponse.setException(e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Protocol.<span class="type">Header</span> <span class="variable">header</span> <span class="operator">=</span> protocol.getHeader();</span><br><span class="line">            header.setType(ProtocolTypeEnum.RESPONSE.getCode());</span><br><span class="line">            Protocol&lt;RpcResponse&gt; responseProtocol = <span class="keyword">new</span> <span class="title class_">Protocol</span>&lt;&gt;(header, rpcResponse);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">Buffer</span> <span class="variable">encodeBuffer</span> <span class="operator">=</span> ProtocolUtils.encode(responseProtocol);</span><br><span class="line">                netSocket.write(encodeBuffer);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Encode Err&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        netSocket.handler(bufferHandlerWrapper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Handler 中, <code>netSocket.handler()</code> 传入一个 <code>Handler&lt;Buffer&gt;</code> 对象, 用于处理通信的字节流.</p>
<p>使用 <code>TcpBufferHandlerWrapper</code> 包裹, 以解决半包&#x2F;粘包问题.</p>
<p>处理的主体逻辑是:</p>
<ul>
<li>通过全局配置获取序列化器, 使用序列化器将传入的 buffer 反序列化成 <code>Protocol&lt;RpcRequest&gt; requestProtocol</code> , 获取其 <code>body</code>, 就是 <code>rpcRequest</code></li>
<li>在 <code>rpcRequest</code> 中获取要调用服务的信息 (服务接口名, 方法名, 参数类型及参数列表), 通过 <code>RpcLocalRegistry</code> 获取服务实现类的 Class 对象, 并使用 <code>invoke</code> 调用获取方法返回结果 <code>result</code></li>
<li>将结果封装进入 <code>rpcResponse</code>, 将 <code>rpcResponse</code> 封装进入 <code>Protocol&lt;RpcResponse&gt; responseProtocol</code></li>
<li>通过之前的序列化器序列化 <code>responseProtocol</code>, 并使用 <code>netSocket.write(encodeBuffer);</code> 将 buffer 写入socket</li>
</ul>
<p><strong>:star:TCP 客户端实现 <code>TcpClient</code></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TcpClient</span> <span class="keyword">implements</span> <span class="title class_">RpcClient</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Vertx</span> <span class="variable">vertx</span> <span class="operator">=</span> Vertx.vertx(); <span class="comment">// signal instance</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">NetClient</span> <span class="variable">netClient</span> <span class="operator">=</span> vertx.createNetClient(<span class="keyword">new</span> <span class="title class_">NetClientOptions</span>()); <span class="comment">// signal instance</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> RpcResponse <span class="title function_">request</span><span class="params">(RpcRequest rpcRequest, ServiceMetaInfo serviceMetaInfo)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        CompletableFuture&lt;RpcResponse&gt; responseCompletableFuture = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        netClient.connect(</span><br><span class="line">                serviceMetaInfo.getServicePost(),</span><br><span class="line">                serviceMetaInfo.getServiceHost(),</span><br><span class="line">                netSocketAsyncResult -&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!netSocketAsyncResult.succeeded()) &#123;</span><br><span class="line">                        System.err.println(netSocketAsyncResult.cause().getMessage());</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="type">NetSocket</span> <span class="variable">netSocket</span> <span class="operator">=</span> netSocketAsyncResult.result();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// make date</span></span><br><span class="line">                    Protocol.<span class="type">Header</span> <span class="variable">header</span> <span class="operator">=</span> Protocol.Header.builder()</span><br><span class="line">                            .magic(ProtocolConst.MAGIC)</span><br><span class="line">                            .version(ProtocolConst.VERSION)</span><br><span class="line">                            .serializer(ProtocolSerializerEnum.getByKey(RpcApplication.getRpcConfig().getSerializer()).getCode())</span><br><span class="line">                            .type(ProtocolTypeEnum.REQUEST.getCode())</span><br><span class="line">                            .requestId(IdUtil.getSnowflakeNextId())</span><br><span class="line">                            .build();</span><br><span class="line">                    Protocol&lt;RpcRequest&gt; rpcRequestProtocol = <span class="keyword">new</span> <span class="title class_">Protocol</span>&lt;&gt;(header, rpcRequest);</span><br><span class="line">                    rpcRequestProtocol.setHeader(header);</span><br><span class="line">                    rpcRequestProtocol.setBody(rpcRequest);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// send data</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="type">Buffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ProtocolUtils.encode(rpcRequestProtocol);</span><br><span class="line">                        netSocket.write(buffer);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Encode failed&quot;</span>, e);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// get response data</span></span><br><span class="line">                    <span class="type">TcpBufferHandlerWrapper</span> <span class="variable">bufferHandlerWrapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TcpBufferHandlerWrapper</span>(buffer -&gt; &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            Protocol&lt;RpcResponse&gt; responseProtocol =</span><br><span class="line">                                    (Protocol&lt;RpcResponse&gt;) ProtocolUtils.decode(buffer);</span><br><span class="line">                            responseCompletableFuture.complete(responseProtocol.getBody());</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Decode failed&quot;</span>, e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    netSocket.handler(bufferHandlerWrapper);</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="type">RpcResponse</span> <span class="variable">rpcResponse</span> <span class="operator">=</span> responseCompletableFuture.get();</span><br><span class="line">        <span class="keyword">return</span> rpcResponse;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>TcpClient</code> 的实例被存储在工厂类中, 但是, 由于 Consumer 要多次调用 <code>request</code> 方法, 因此选择把 <code>Vertx</code> 和 <code>NetClient</code> 实例作为静态变量, 避免每次调用 <code>request</code> 的时候都创建连接.</p>
<p>将以上的 <code>RpcServer</code> 和 <code>RpcClient</code> 分开构建的原因是: 为了满足一个节点作为 Consumer 的同时也提供服务, 作为 Provider. </p>
<p><strong>:star:解决半包粘包处理器 <code>TcpBufferHandlerWrapper</code></strong></p>
<p>为了解决 TCP 传输中的半包粘包问题, 构造一个处理器, 它实现并增强 <code>Handler&lt;Buffer&gt;</code> 接口. 这种做法是设计模式中的 <strong>装饰者模式</strong>, 使用 <code>RecordParser</code> 对原有的 <code>Buffer</code> 处理器的能力进行增强. 装饰者模式可以简单理解为给对象穿装备, 增强对象的能力. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TcpBufferHandlerWrapper</span> <span class="keyword">implements</span> <span class="title class_">Handler</span>&lt;Buffer&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RecordParser recordParser;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RecordParser <span class="title function_">initRecordParser</span><span class="params">(Handler&lt;Buffer&gt; bufferHandler)</span> &#123;</span><br><span class="line">        <span class="type">RecordParser</span> <span class="variable">parser</span> <span class="operator">=</span> RecordParser.newFixed(ProtocolConst.HEADER_LENGTH);</span><br><span class="line">        parser.setOutput(<span class="keyword">new</span> <span class="title class_">Handler</span>&lt;Buffer&gt;() &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">bodyLength</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="type">Buffer</span> <span class="variable">resultBuffer</span> <span class="operator">=</span> Buffer.buffer();</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(Buffer buffer)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (-<span class="number">1</span> == bodyLength) &#123;</span><br><span class="line">                    <span class="comment">// 1. 首先解析 Header（固定长度 17 字节）</span></span><br><span class="line">                    bodyLength = buffer.getInt(<span class="number">13</span>); <span class="comment">// 获取 Body 的长度，假设Header的索引 13..=16 字节表示 BodyLength</span></span><br><span class="line">                    parser.fixedSizeMode(bodyLength); <span class="comment">// 根据Body的长度设置接下来的解析模式</span></span><br><span class="line">                    resultBuffer.appendBuffer(buffer); <span class="comment">// 将Header数据缓存起来</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 2. 接收 Body 数据</span></span><br><span class="line">                    resultBuffer.appendBuffer(buffer); <span class="comment">// 将接收到的Body数据添加到缓存中</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (resultBuffer.length() &gt;= bodyLength + ProtocolConst.HEADER_LENGTH) &#123;</span><br><span class="line">                        bufferHandler.handle(resultBuffer); <span class="comment">// 调用外部传入的回调，处理完整的消息</span></span><br><span class="line">                        <span class="comment">// 4. 处理完后，重置状态，准备处理下一个数据包</span></span><br><span class="line">                        parser.fixedSizeMode(ProtocolConst.HEADER_LENGTH);</span><br><span class="line">                        bodyLength = -<span class="number">1</span>; <span class="comment">// 重置Body长度</span></span><br><span class="line">                        resultBuffer = Buffer.buffer(); <span class="comment">// 重置缓存</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> parser;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TcpBufferHandlerWrapper</span><span class="params">(Handler&lt;Buffer&gt; bufferHandler)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.recordParser = initRecordParser(bufferHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(Buffer buffer)</span> &#123;</span><br><span class="line">        recordParser.handle(buffer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SPI-组件-com-ypy-pyrpc-spi"><a href="#SPI-组件-com-ypy-pyrpc-spi" class="headerlink" title="SPI 组件 com.ypy.pyrpc.spi"></a>SPI 组件 <code>com.ypy.pyrpc.spi</code></h3><p>**SPI (Service Provider Interface) ** 是一种服务发现机制, 用于在运行时动态加载实现类. 它是 Java 提供的一种标准扩展点机制, 允许框架或库定义接口, 并由第三方提供实现. SPI 的核心思想是 <strong>解耦接口与实现</strong>, 使得应用程序可以在不修改代码的情况下扩展功能. 说白了, 就是SDK中提供一些接口和默认实现类, 当开发者不想使用SDK提供的实现类时, 他们可以自己写一个实现类, 并通过配置让SDK使用自定义的实现类.</p>
<p><strong>:star:SPI导入器<code>SpiLoader</code>​</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpiLoader</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * store the class that has been load, &#123;interfaceName: &#123;implClassKey: implClass&#125;&#125;</span></span><br><span class="line"><span class="comment">     * className means full name, e.g. com.ypy.pyrpc.spi.serializer.Serializer</span></span><br><span class="line"><span class="comment">     * classKey means a short key, representing some implClass, e.g. jdk=JdkSerializer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Map&lt;String, Class&lt;?&gt;&gt;&gt; spiMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * cache of instance, avoid repeat &quot;new&quot;</span></span><br><span class="line"><span class="comment">     * &#123;implClassName: implClassInstance&#125;</span></span><br><span class="line"><span class="comment">     * full-name, not a key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Object&gt; implClassInstanceCache = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;String, Object&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">RPC_SYSTEM_SPI_DIR</span> <span class="operator">=</span> <span class="string">&quot;META-INF/pyrpc/system/&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">RPC_CUSTOM_SPI_DIR</span> <span class="operator">=</span> <span class="string">&quot;META-INF/pyrpc/custom/&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] SCAN_DIRS = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;RPC_SYSTEM_SPI_DIR, RPC_CUSTOM_SPI_DIR&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, Class&lt;?&gt;&gt; load(Class&lt;?&gt; interfaceClass) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">interfaceName</span> <span class="operator">=</span> interfaceClass.getName();</span><br><span class="line">        Map&lt;String, Class&lt;?&gt;&gt; implKey2implClassMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(); <span class="comment">// &#123;implClassKey: implClass&#125;</span></span><br><span class="line">        <span class="keyword">for</span> (String dir : SCAN_DIRS) &#123;</span><br><span class="line">            List&lt;URL&gt; resources = ResourceUtil.getResources(dir + interfaceName);</span><br><span class="line">            <span class="keyword">for</span> (URL resource : resources) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(resource.openStream());</span><br><span class="line">                    <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(isr);</span><br><span class="line">                    <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">while</span> ((line = br.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                        String[] split = line.split(<span class="string">&quot;=&quot;</span>);</span><br><span class="line">                        <span class="keyword">if</span> (split.length == <span class="number">2</span>) &#123;</span><br><span class="line">                            <span class="type">String</span> <span class="variable">implClassKey</span> <span class="operator">=</span> split[<span class="number">0</span>];</span><br><span class="line">                            <span class="type">String</span> <span class="variable">implClassName</span> <span class="operator">=</span> split[<span class="number">1</span>];</span><br><span class="line">                            implKey2implClassMap.put(implClassKey, Class.forName(implClassName));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;spi resource load error&quot;</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        spiMap.put(interfaceName, implKey2implClassMap);</span><br><span class="line">        <span class="keyword">return</span> implKey2implClassMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">getInstance</span><span class="params">(Class&lt;T&gt; interfaceClass, String implClassKey)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">interfaceName</span> <span class="operator">=</span> interfaceClass.getName();</span><br><span class="line">        Map&lt;String, Class&lt;?&gt;&gt; implKey2implClassMap = spiMap.get(interfaceName);</span><br><span class="line">        <span class="keyword">if</span> (implKey2implClassMap == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Interface &quot;</span> + interfaceName + <span class="string">&quot; has no implement classes&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!implKey2implClassMap.containsKey(implClassKey)) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Interface &quot;</span> + interfaceName + <span class="string">&quot; has no implement &quot;</span> + implClassKey);</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; implClass = implKey2implClassMap.get(implClassKey);</span><br><span class="line">        <span class="keyword">if</span> (!implClassInstanceCache.containsKey(implClass.getName())) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                implClassInstanceCache.put(implClass.getName(), implClass.newInstance());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Write &quot;</span> + implClass.getName() + <span class="string">&quot; into cache failed&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (T) implClassInstanceCache.get(implClass.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用两个<code>ConcurrentHashMap</code>存贮功能接口和实现类的信息, 并引入缓存机制:</p>
<ul>
<li><code>spiMap</code> 的存储模式是: <code>&#123;interfaceName: &#123;implClassKey: implClass&#125;&#125;</code>, 例如 <code>&#123;&quot;Registry&quot; : &#123;&quot;jdk&quot;: Class&lt;JdkRegistry&gt;, &quot;json&quot;: Class&lt;JsonRegistry&gt;&#125;&#125;</code></li>
<li><code>implClassInstanceCache</code> 的存储模式是: <code>&#123;implClassName: implClassInstance&#125;</code>, 例如 <code>&#123;&quot;JdkRegistry&quot;: JdkRegistry&#125;</code>. 作为对象缓存, 避免重复new对象</li>
</ul>
<p>使用SPI机制, 为以下四个功能模块提供了可定制化选择: 1) 注册中心; 2) 序列化器; 3) 负载均衡器; 4) 重试和容错器. 它们有对应的工厂类, 例如</p>
<p><strong>:stars:<code>RegistryFactory</code></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegistryFactory</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123; SpiLoader.load(Registry.class); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Registry <span class="title function_">getInstance</span><span class="params">(String implClassKey)</span> &#123; <span class="keyword">return</span> SpiLoader.getInstance(Registry.class, implClassKey); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当项目加载时, 工厂类的 <code>static</code> 部分会调用 <code>loader</code> 方法, 将默认实现类和用户实现类加入 <code>SpiLoader</code> 中的字典容器, 同时, 由于是先载入框架默认实现类后载入用户自定义实现类, 因此用户自定义的key会覆盖框架默认的key, 这样是更加合理的. </p>
<p>下面分别介绍一下框架中的默认实现类.</p>
<h4 id="序列化器组件-com-ypy-pyrpc-spi-serializer"><a href="#序列化器组件-com-ypy-pyrpc-spi-serializer" class="headerlink" title="序列化器组件 com.ypy.pyrpc.spi.serializer"></a>序列化器组件 <code>com.ypy.pyrpc.spi.serializer</code></h4><p><strong>:star:<code>Serializer</code> 接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Serializer</span> &#123;</span><br><span class="line">    &lt;T&gt; <span class="type">byte</span>[] serialize(T obj) <span class="keyword">throws</span> IOException;</span><br><span class="line">    &lt;T&gt; T <span class="title function_">deserialize</span><span class="params">(<span class="type">byte</span>[] data, Class&lt;T&gt; type)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>框架提供的默认实现类在 <code>impl</code> 包中, 有 JDK, JSON, KRYO 三种序列化器. </p>
<h4 id="注册中心组件-com-ypy-pyrpc-spi-registry"><a href="#注册中心组件-com-ypy-pyrpc-spi-registry" class="headerlink" title="注册中心组件 com.ypy.pyrpc.spi.registry"></a>注册中心组件 <code>com.ypy.pyrpc.spi.registry</code></h4><p><strong>:smile:形象的例子</strong></p>
<p>食客 - 点餐平台 (美团) - 饭馆: 食客 &#x3D; Consumer, 美团 &#x3D; 注册中心, 餐馆 &#x3D; Provider. </p>
<p>食客从美团不是去吃菜 (调用服务), 而是获取餐馆和菜品信息, 然后再去餐馆吃菜 (发起 RPC 请求). </p>
<p>餐馆 (Provider) 要先做菜 (把提供的服务存入本地注册中心 <code>RpcLocalRegistry</code>) 再把相应的菜品信息存入美团 (把提供的服务的信息提交给 <code>Registry</code>, <code>Registry</code> 把信息存入 ETCD), 这样顾客才能发现菜品. </p>
<p>所谓服务发现缓存, 实际就是, 当一个食客经常去某餐馆吃饭, 他去多了, 也就没有必要次次都去到美团上查看关于餐馆的信息 (例如在哪里, 有哪些菜品). </p>
<p><strong>:star:<code>Registry</code>​ 接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Registry</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * initialize registry for both PROVIDER and CONSUMER</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> registryConfig</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(RpcConfig.RegistryConfig registryConfig)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * help PROVIDER to register their service (info) into registry</span></span><br><span class="line"><span class="comment">     * and these services should also be registered and managed by LocalRegistry</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serviceMetaInfo</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(ServiceMetaInfo serviceMetaInfo)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * help PROVIDER to unregister service</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serviceMetaInfo</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">unregister</span><span class="params">(ServiceMetaInfo serviceMetaInfo)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * help CONSUMER to search a group of service meta info by ServiceNameVersion</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serviceNameVer: &quot;serviceName:serviceVersion&quot;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;ServiceMetaInfo&gt; <span class="title function_">serviceDiscovery</span><span class="params">(String serviceNameVer)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * when a PROVIDER offline, clear correlative service info it provided in registry</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * send update message to registry, confirming PROVIDED alive</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">heartBeat</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * help CONSUMER to watch PROVIDER, when a Provider offline (actively or passively), it will update local cache info of CONSUMER</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fullRegistryServiceKey: /[RPC_ROOT_PATH]/[ServiceName]:[ServiceVersion]/[ServiceAddr]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">watch</span><span class="params">(String fullRegistryServiceKey, String serviceNameVer)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注册中心接口有六个方法, 分别是注册中心初始化, 服务注册, 服务注销, 服务发现, 节点关闭, 心跳检测, 以及节点监视. </p>
<p>在 <code>impl</code> 包中, 提供了 ETCD 的默认实现 (<code>com.ypy.pyrpc.spi.registry.impl.EtcdRegistry</code>), 以及无注册中心的实现 <code>NoRegistry</code>. </p>
<p>实现一个注册中心是一个难点, 我们详细说一下:</p>
<p><strong>:stars:<code>EtcdRegistry</code>​ ETCD 注册中心</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EtcdRegistry</span> <span class="keyword">implements</span> <span class="title class_">Registry</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Client cli;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> KV kvCli;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ETCD_ROOT_PATH</span> <span class="operator">=</span> <span class="string">&quot;/pyrpc/&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * fullRegistryServiceKey: /pyrpc/com.....UserService:1.0.0/http://127.0.0.1:8080</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * this collection stores data for PROVIDER</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; loaclFullRegistryServiceKeySet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * key is serviceNameVersion</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * this collection stores data for CONSUMER, make convenience through cache ServiceNameVer and their MetaInfo</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, List&lt;ServiceMetaInfo&gt;&gt; serviceNameVerCache = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; watchingNodeKeySet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(RpcConfig.RegistryConfig registryConfig)</span> &#123;</span><br><span class="line">        cli = Client.builder()</span><br><span class="line">                .endpoints(registryConfig.getAddr())</span><br><span class="line">                .connectTimeout(Duration.ofMillis(registryConfig.getTimeout()))</span><br><span class="line">                .build();</span><br><span class="line">        kvCli = cli.getKVClient();</span><br><span class="line">        heartBeat();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(ServiceMetaInfo serviceMetaInfo)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Lease</span> <span class="variable">leaseCli</span> <span class="operator">=</span> cli.getLeaseClient();</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">leaseId</span> <span class="operator">=</span> leaseCli.grant(<span class="number">30L</span>).get().getID();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">fullRegistryServiceKey</span> <span class="operator">=</span> ETCD_ROOT_PATH + serviceMetaInfo.getServiceNameVerAddr();</span><br><span class="line">        <span class="type">ByteSequence</span> <span class="variable">k</span> <span class="operator">=</span> ByteSequence.from(fullRegistryServiceKey, StandardCharsets.UTF_8);</span><br><span class="line">        <span class="type">ByteSequence</span> <span class="variable">v</span> <span class="operator">=</span> ByteSequence.from(JSONUtil.toJsonStr(serviceMetaInfo), StandardCharsets.UTF_8);</span><br><span class="line"></span><br><span class="line">        <span class="type">PutOption</span> <span class="variable">putOption</span> <span class="operator">=</span> PutOption.builder().withLeaseId(leaseId).build();</span><br><span class="line">        kvCli.put(k, v, putOption).get();</span><br><span class="line">        loaclFullRegistryServiceKeySet.add(fullRegistryServiceKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unregister</span><span class="params">(ServiceMetaInfo serviceMetaInfo)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">fullRegistryServiceKey</span> <span class="operator">=</span> ETCD_ROOT_PATH + serviceMetaInfo.getServiceNameVerAddr();</span><br><span class="line">        kvCli.delete(ByteSequence.from(fullRegistryServiceKey, StandardCharsets.UTF_8));</span><br><span class="line">        loaclFullRegistryServiceKeySet.remove(serviceMetaInfo.getServiceNameVerAddr());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;ServiceMetaInfo&gt; <span class="title function_">serviceDiscovery</span><span class="params">(String serviceNameVer)</span> &#123;</span><br><span class="line">        List&lt;ServiceMetaInfo&gt; cachedServiceMetaInfos = serviceNameVerCache.get(serviceNameVer);</span><br><span class="line">        <span class="keyword">if</span> (cachedServiceMetaInfos != <span class="literal">null</span>) <span class="keyword">return</span> cachedServiceMetaInfos;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// search in etcd</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">searchPrefix</span> <span class="operator">=</span> ETCD_ROOT_PATH + serviceNameVer + <span class="string">&quot;/&quot;</span>; <span class="comment">// add &quot;/&quot; means search for group</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">GetOption</span> <span class="variable">getOption</span> <span class="operator">=</span> GetOption.builder().isPrefix(<span class="literal">true</span>).build();</span><br><span class="line">            List&lt;KeyValue&gt; kvs = kvCli.get(</span><br><span class="line">                    ByteSequence.from(searchPrefix, StandardCharsets.UTF_8),</span><br><span class="line">                    getOption</span><br><span class="line">            ).get().getKvs();</span><br><span class="line"></span><br><span class="line">            List&lt;ServiceMetaInfo&gt; serviceMetaInfoList = kvs.stream()</span><br><span class="line">                    .map(kv -&gt; &#123;</span><br><span class="line">                        <span class="type">String</span> <span class="variable">fullRegistryServiceKey</span> <span class="operator">=</span> kv.getKey().toString(StandardCharsets.UTF_8);</span><br><span class="line">                        watch(fullRegistryServiceKey, serviceNameVer);</span><br><span class="line">                        <span class="type">String</span> <span class="variable">val</span> <span class="operator">=</span> kv.getValue().toString(StandardCharsets.UTF_8);</span><br><span class="line">                        <span class="keyword">return</span> JSONUtil.toBean(val, ServiceMetaInfo.class);</span><br><span class="line">                    &#125;).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">            serviceNameVerCache.put(serviceNameVer, serviceMetaInfoList);</span><br><span class="line">            <span class="keyword">return</span> serviceMetaInfoList;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Get service list failed&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (String key : loaclFullRegistryServiceKeySet) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                kvCli.delete(ByteSequence.from(key, StandardCharsets.UTF_8));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(key + <span class="string">&quot;: delete etcd node failed&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (kvCli != <span class="literal">null</span>) kvCli.close();</span><br><span class="line">        <span class="keyword">if</span> (cli != <span class="literal">null</span>) cli.close();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Destroy Current Node&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">heartBeat</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// every 10 seconds, update lease for all services provided by current Provider</span></span><br><span class="line">        CronUtil.schedule(<span class="string">&quot;*/10 * * * * *&quot;</span>, <span class="keyword">new</span> <span class="title class_">Task</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (String key : loaclFullRegistryServiceKeySet) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        List&lt;KeyValue&gt; kvs = kvCli.get(ByteSequence.from(key, StandardCharsets.UTF_8))</span><br><span class="line">                                .get()</span><br><span class="line">                                .getKvs();</span><br><span class="line">                        <span class="keyword">if</span> (kvs.isEmpty()) <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="type">KeyValue</span> <span class="variable">kv</span> <span class="operator">=</span> kvs.get(<span class="number">0</span>);</span><br><span class="line">                        <span class="type">String</span> <span class="variable">val</span> <span class="operator">=</span> kv.getValue().toString(StandardCharsets.UTF_8);</span><br><span class="line">                        <span class="type">ServiceMetaInfo</span> <span class="variable">serviceMetaInfo</span> <span class="operator">=</span> JSONUtil.toBean(val, ServiceMetaInfo.class);</span><br><span class="line">                        register(serviceMetaInfo);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(key + <span class="string">&quot;: updating lease failed&quot;</span>, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        CronUtil.setMatchSecond(<span class="literal">true</span>);</span><br><span class="line">        CronUtil.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">watch</span><span class="params">(String fullRegistryServiceKey, String serviceNameVer)</span> &#123;</span><br><span class="line">        <span class="type">Watch</span> <span class="variable">watchCli</span> <span class="operator">=</span> cli.getWatchClient();</span><br><span class="line">        <span class="keyword">if</span> (watchingNodeKeySet.add(fullRegistryServiceKey)) &#123;</span><br><span class="line">            watchCli.watch(ByteSequence.from(fullRegistryServiceKey, StandardCharsets.UTF_8), watchResponse -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (WatchEvent event : watchResponse.getEvents()) &#123;</span><br><span class="line">                    <span class="keyword">switch</span> (event.getEventType()) &#123;</span><br><span class="line">                        <span class="keyword">case</span> DELETE:</span><br><span class="line">                            serviceNameVerCache.remove(serviceNameVer);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> PUT:</span><br><span class="line">                        <span class="keyword">default</span>:</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先看成员变量: 由于 <code>EtcdRegistry</code> 实例是被保存在 <code>SpiLoader</code> 中, 因此每次获取实例时并不会重复创建实例, 所以其中的成员变量都不需要设置为 <code>static</code>.</p>
<ul>
<li><code>Client cli</code> 是 <code>jetcd</code> 中, 操作 ETCD 的客户端, <code>jectd</code> 是专门为 Java 操作 ECTD 的 SDK, 相当于 Jedis &#x2F; Redission 之于 Redis</li>
<li><code>kvCli</code> 是由 <code>cli</code> 生成的操作键值对的客户端</li>
<li><code>ETCD_ROOT_PATH</code> 是存储在 ETCD 数据库中本项目的标识前缀, 用来与其它项目区分</li>
<li><code>Set&lt;String&gt; loaclFullRegistryServiceKeySet</code> 是存储本地 (也就是当前 Provider) 中提供的服务信息, 它里面存的是服务的全部信息, 其结构为 <code>/pyrpc/com.....UserService:1.0.0/http://127.0.0.1:8080</code> 即前缀 + 服务接口名 + 版本号 + Provider 地址</li>
<li><code>Map&lt;String, List&lt;ServiceMetaInfo&gt;&gt; serviceNameVerCache</code> 是为 <strong>Consumer</strong> 提供的服务发现缓存, 因为 Consumer 发送 RPC 请求是很频繁的, 我们没有必要每一次都向 ETCD 请求服务信息, 而是选择把对应的信息缓存起来, 这样 Consumer 就可以更加高效的获取服务信息, 再提供信息发送RPC请求了. 由于发现服务是 Consumer 提供服务接口名和版本号, 因此 <code>serviceNameVerCache</code> 的 key 结构为 <code>com.....UserService:1.0.0</code></li>
<li><code>Set&lt;String&gt; watchingNodeKeySet</code> 是为 Consumer 提供的监视机制, 它存储了正在监视的结点, 里面存储的是 <code>fullRegistryServiceKey</code>, 也就是前缀 + 服务接口名 + 版本号 + Provider 地址的全部信息</li>
</ul>
<p>再来看方法实现:</p>
<ul>
<li><code>init</code> 是初始化方法, 包括创建相应的 Java ETCD 客户端</li>
<li><code>register</code> 是服务注册, 主要完成写入信息到 ETDC 和写入信息到本地 <code>loaclFullRegistryServiceKeySet</code></li>
<li><code>serviceDiscovery</code> 是通过服务接口名和版本号来发现服务, 先查看缓存, 缓存没有再向 ETCD 拉取, 同时存入缓存. 存入缓存的服务需要监视其节点, 于是要调用 <code>watch(fullRegistryServiceKey, serviceNameVer);</code> 方法</li>
<li><code>destroy</code> 是 Provider 端的主动下线机制, 当一个 Provider 停机了, 会将情况先行上报给 ETCD 以避免 Consumer 的错误调用</li>
<li><code>heartBeat</code> 是 Provider 端的被动下线机制, 当一个 Provider 因为异常停机, 例如断电, 这时候就无法执行 <code>destroy</code> 了. 心跳检测的原理是 Provider 定时 (10 s) 向注册中心更新一次服务信息, ETCD 则对每一个节点的信息设置一个稍长的过期时间 (30 s). 当 Provider 因为异常停机, 其对应的节点就会因为无法续期而被 ETCD 删除. 因此异常停机造成的影响最多持续 30 s.</li>
<li><code>watch</code> 是为 Consumer 检测 Provider 状态的, 当一个 Provider 下线 (主动或被动), Consumer 就会收到 ETCD 的相应, 并删除对应的服务信息缓存</li>
</ul>
<p>以上的做法维护了: </p>
<ul>
<li>数据一致性: 当某个 Provider 下线了, 注册中心需要即时剔除它的结点服务信息.</li>
<li>性能优化: Consumer 每次都要从注册中心获取服务, 可以使用缓存进行优化. </li>
<li>高可用性: 保证注册中心不会宕机. </li>
<li>高扩展性: 提供不同的注册中心实现类, 并使用 SPI 机制运行用户自定义注册中心实现类.</li>
</ul>
<h4 id="负载均衡组件-com-ypy-pyrpc-spi-loadbalancer"><a href="#负载均衡组件-com-ypy-pyrpc-spi-loadbalancer" class="headerlink" title="负载均衡组件 com.ypy.pyrpc.spi.loadbalancer"></a>负载均衡组件 <code>com.ypy.pyrpc.spi.loadbalancer</code></h4><p>为 Consumer 从众多内容相同但 Provider 不同的服务结点中, 依据某种算法选择恰当的服务节点, 这样可以合理分配 Provider 端的压力. </p>
<p><strong>:stars:<code>Loadbalancer</code> 接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Loadbalancer</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serviceMetaInfoList</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context: Provide additional contextual information for load balancing algorithms to more intelligently select service instances.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ServiceMetaInfo <span class="title function_">select</span><span class="params">(List&lt;ServiceMetaInfo&gt; serviceMetaInfoList, Map&lt;String, Object&gt; context)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用轮询, 随机, 和一致哈希等方法实现了默认的三种序列化器实现</p>
<h4 id="重试和容错组件-com-ypy-pyrpc-spi-retry-com-ypy-pyrpc-spi-tolerance"><a href="#重试和容错组件-com-ypy-pyrpc-spi-retry-com-ypy-pyrpc-spi-tolerance" class="headerlink" title="重试和容错组件 com.ypy.pyrpc.spi.retry &amp; com.ypy.pyrpc.spi.tolerance"></a>重试和容错组件 <code>com.ypy.pyrpc.spi.retry</code> &amp; <code>com.ypy.pyrpc.spi.tolerance</code></h4><p>这一部分只做了简单的实现和占位, 开发者可以使用SPI机制自定义实现</p>

    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/rpc/" rel="tag"><i class="fa fa-tag"></i> rpc</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/12/01/lang/mykotlin/" rel="prev" title="My Kotlin">
      <i class="fa fa-chevron-left"></i> My Kotlin
    </a></div>
      <div class="post-nav-item">
    <a href="/2025/04/12/tech/wsl/" rel="next" title="WSL">
      WSL <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#pyRPC-Framework"><span class="nav-number">1.</span> <span class="nav-text">pyRPC Framework</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#What-is-RPC"><span class="nav-number">1.1.</span> <span class="nav-text">What is RPC?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Consumer-Provider-Model"><span class="nav-number">1.2.</span> <span class="nav-text">Consumer &#x2F; Provider Model</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9D%97-common-example"><span class="nav-number">1.2.1.</span> <span class="nav-text">共享模块 (common-example)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Consumer"><span class="nav-number">1.2.2.</span> <span class="nav-text">Consumer</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#zero-%E5%88%9D%E5%A7%8B%E5%8C%96-Consumer-%E7%AB%AF%E9%85%8D%E7%BD%AE"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">:zero:初始化 Consumer 端配置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#one-Consumer-%E4%BD%BF%E7%94%A8%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%B7%A5%E5%8E%82-ServiceProxyFactory-%E8%8E%B7%E5%8F%96%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">:one:Consumer 使用动态代理工厂 ServiceProxyFactory 获取代理对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#two-ServiceProxy-%E5%B8%AE%E5%8A%A9-Consumer-%E5%AE%8C%E6%88%90%E5%AF%B9%E8%AF%B7%E6%B1%82%E7%9A%84%E5%B0%81%E8%A3%85-%E5%8F%91%E9%80%81-%E5%B9%B6%E6%8E%A5%E5%8F%97%E5%93%8D%E5%BA%94"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">:two:ServiceProxy 帮助 Consumer 完成对请求的封装, 发送, 并接受响应</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Provider-provider-example"><span class="nav-number">1.2.3.</span> <span class="nav-text">Provider (provider-example)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#zero-Provider-%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">:zero:Provider 的初始化流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#one-RpcServer%E5%B8%AE%E5%8A%A9-Provider-%E5%AE%8C%E6%88%90%E5%AF%B9%E8%AF%B7%E6%B1%82%E7%9A%84%E6%8E%A5%E6%94%B6-%E8%A7%A3%E6%9E%90-%E5%B9%B6%E5%8F%91%E9%80%81%E5%93%8D%E5%BA%94"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">:one:RpcServer帮助 Provider 完成对请求的接收, 解析, 并发送响应</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RPC-pyrpc"><span class="nav-number">1.2.4.</span> <span class="nav-text">RPC (pyrpc)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Main-Components-in-pyRPC"><span class="nav-number">1.3.</span> <span class="nav-text">Main Components in pyRPC</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%84%E4%BB%B6%E5%92%8C%E9%85%8D%E7%BD%AE%E7%BB%84%E4%BB%B6-com-ypy-pyrpc-model-com-ypy-pyrpc-config"><span class="nav-number">1.3.1.</span> <span class="nav-text">数据组件和配置组件: com.ypy.pyrpc.model &amp; com.ypy.pyrpc.config</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8%E7%BB%84%E4%BB%B6-com-ypy-pyrpc-bootstrap"><span class="nav-number">1.3.2.</span> <span class="nav-text">启动组件 com.ypy.pyrpc.bootstrap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E7%BB%84%E4%BB%B6-com-ypy-pyrpc-app"><span class="nav-number">1.3.3.</span> <span class="nav-text">全局组件 com.ypy.pyrpc.app</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%90%86%E7%BB%84%E4%BB%B6-com-ypy-pyrpc-proxy"><span class="nav-number">1.3.4.</span> <span class="nav-text">代理组件 com.ypy.pyrpc.proxy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BB%84%E4%BB%B6-com-ypy-pyrpc-server"><span class="nav-number">1.3.5.</span> <span class="nav-text">服务器组件 com.ypy.pyrpc.server</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%8F%E8%AE%AE%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%84%E4%BB%B6-com-ypy-pyrpc-server-tcp-protocol"><span class="nav-number">1.3.5.1.</span> <span class="nav-text">协议数据结构组件 com.ypy.pyrpc.server.tcp.protocol</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%9E%E7%8E%B0%E7%BB%84%E4%BB%B6-com-ypy-pyrpc-server-tcp"><span class="nav-number">1.3.5.2.</span> <span class="nav-text">TCP 服务器实现组件 com.ypy.pyrpc.server.tcp</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SPI-%E7%BB%84%E4%BB%B6-com-ypy-pyrpc-spi"><span class="nav-number">1.3.6.</span> <span class="nav-text">SPI 组件 com.ypy.pyrpc.spi</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8%E7%BB%84%E4%BB%B6-com-ypy-pyrpc-spi-serializer"><span class="nav-number">1.3.6.1.</span> <span class="nav-text">序列化器组件 com.ypy.pyrpc.spi.serializer</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E7%BB%84%E4%BB%B6-com-ypy-pyrpc-spi-registry"><span class="nav-number">1.3.6.2.</span> <span class="nav-text">注册中心组件 com.ypy.pyrpc.spi.registry</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%BB%84%E4%BB%B6-com-ypy-pyrpc-spi-loadbalancer"><span class="nav-number">1.3.6.3.</span> <span class="nav-text">负载均衡组件 com.ypy.pyrpc.spi.loadbalancer</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E8%AF%95%E5%92%8C%E5%AE%B9%E9%94%99%E7%BB%84%E4%BB%B6-com-ypy-pyrpc-spi-retry-com-ypy-pyrpc-spi-tolerance"><span class="nav-number">1.3.6.4.</span> <span class="nav-text">重试和容错组件 com.ypy.pyrpc.spi.retry &amp; com.ypy.pyrpc.spi.tolerance</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Perry Yao"
      src="https://avatars.githubusercontent.com/u/126999663?v=4">
  <p class="site-author-name" itemprop="name">Perry Yao</p>
  <div class="site-description" itemprop="description">...</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">53</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/PerryYao-GitHub" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;PerryYao-GitHub" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:peiyouyao@gmail.com" title="E-Mail → mailto:peiyouyao@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Perry Yao</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
